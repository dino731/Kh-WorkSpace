package com.kh.spring.member.controller;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.servlet.http.HttpSession;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.validation.BindingResult;
import org.springframework.validation.ObjectError;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.WebDataBinder;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.InitBinder;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.servlet.mvc.support.RedirectAttributes;

import com.kh.spring.member.model.service.MemberService;
import com.kh.spring.member.model.validator.MemberValidator;
import com.kh.spring.member.model.vo.Member;

@Controller
// Contoroller 타입의 어노테이션을 붙여주면 빈 스캐너가 자동으로 빈으로 등록해줌. (servlet-context.xml안에 있는 <context:component-scan>태그)
//@RequestMapping("/member") -> 공통주소 (클래스레벨에 선언)
// localhost:8081/spring/member(공통주소)/login.me(그 외 주소, 메소드 레벨에 선언)
//단, 클래스 레벨에 @RequesetMapping이 존재하지 않는 경우 메서드레벨에서 단독으로 요청을 처리한다.
public class MemberController {

	/* 
	 * 기존객체 생성 방식
	 * private Memberservice  mService = new MemberService();
	 * 
	 * 서비스가 동시에 많은 횟수가 요청이 되면 그만큼 많은 객체가 생성된다.
	 * 
	 * Spring의 DI(Dependency Injection) -> 객체를 스프링에서 직접 생성해서 주입해주는 개념
	 * 
	 * new 연산자를 쓰지 않고 선언만 한 후 @Autowired 어노테이션을 붙이면 객체를 주입받을 수 있다.
	 * 
	 * */
	
//	@Autowired
	private MemberService mService;
	private MemberValidator memValidator;
	private BCryptPasswordEncoder bcryptPasswordEncoder;
	
	/*
	 * 필드 주입 방식의 장점 : 이해하기 편함. 사용하기도 편함.
	 * 
	 * 필드 주입 방식의 단점 : 순환 의존성 문제가 발생할 수 있다.
	 * 					  무분별한 주입시 의존관계를 확인하기 어렵다
	 * 					  final 예약어를 지정할 수가 없다.
	 * 
	 * */ 
	// 생성자 주입 방식
	public MemberController() {
		
	}
	
	@Autowired
	public MemberController(MemberService mService, MemberValidator memvalidator , BCryptPasswordEncoder bcryptPasswordEncoder) {
		this.mService = mService;
		this.memValidator = memvalidator;
		
	}
	/*
	 * 의존성 주입시 권장하는 방식
	 * 생성자에 참조할 클래스를 인자로 받아서 필드에 매핑시킴
	 * 
	 * 장점 : 현재 클래스에서 내가 주입시킬 객체들을 모아서 관리할 수 있기 때문에 한눈에 알아보기 편함
	 * 		 코드 분석과 테스트에 유리하며, final로 필드값을 받을 수 있어서 안전하다
	 * */  
	
	/*
	 * 그외 방식
	 * Setter 주입방식 : setter메서드로 빈을 주입받는 방식
	 * 생성자에 너무 많은 의존성을 주입하게 되면 알아보기 힘들다는 단점이 있어서 보완하기 위해 사용하거나,
	 * 혹은 의존성이 항상 필요한 경우가 아니라 선택사항이라면 사용함.
	 * 
	 * */  
	@Autowired
	public void setMemberService(MemberService memberService) {
		this.mService = memberService;
	}
	
	@InitBinder
	public void initBinder(WebDataBinder binder) {
		binder.addValidators(memValidator);
	}
//	@RequestMapping( value = "login.me", method = RequestMethod.POST) // RequestMapping이라는 어노테이션을 붙이면 HandlerMapping 곳에 등록이 된다.
	//()안에 여러개의 속성을 추가할 수 있다.
	/*
	 * 스프링에서 parameter(요청시 전달 값)을 받는 방법
	 * 1. HttpServletRequest request를 이용해서 전달 받기(기존 방식 그대로)
	 * 해당 메소드의 매개변수로 HttpServletRequest를 작성해 놓으면 스프링 컨데이너가 해당 메소드를 호출할 때
	 * 자동으로 request객체를 생성해서 매개 변수로 주입해준다.
	 * */
//	public String loginMember(HttpServletRequest request) {
//		String userId = request.getParameter("userId");
//		String userPwd = request.getParameter("userPwd");
//		
//		System.out.println("userId :"+userId);
//		System.out.println("userPwd :"+userPwd);
//		
//		return "main";
//	}
	
	/*
	 * 2. @RequestParam어노테이션을 이용하는 방법.
	 * 		기존의 request.getParameter("키")로 뽑는 역할을 대신 수행해주는 어노테이션
	 * 		input 속성의 value로 jsp에서 작성했던 name값을 입력해주면 알아서 매개변수로 값을 담아온다.
	 * 		만약 넘어온 값이 비어있다면 defaultValue로 설정 가능
	 * 
	 * */
//	@RequestMapping( value = "login.me", method = RequestMethod.POST) // RequestMapping이라는 어노테이션을 붙이면 HandlerMapping 곳에 등록이 된다.
//	public String loginMember(@RequestParam(value="userId" , defaultValue="m") String userId,
//							  @RequestParam(value="userPwd") String userPwd
//			) {
//		System.out.println("userId :"+userId);
//		System.out.println("userPwd :"+userPwd);
//		
//		return "main";
//	}
	
	/*
	 * 3. @RequestParam어노테이션을 생략하는 방법.
	 * 단, 매개변수의 변수명을 jsp에서 전달한 파라미터의 name속성값과 일치시켜줘야한다.
	 * + defaultValue사용 불가
	 * 
	 * */
//	@RequestMapping( value = "login.me", method = RequestMethod.POST) // RequestMapping이라는 어노테이션을 붙이면 HandlerMapping 곳에 등록이 된다.
//	public String loginMember(String userId,String userPwd) {
//		System.out.println("userId :"+userId);
//		System.out.println("userPwd :"+userPwd);
//		
//		return "main";
//	}
	
	/*
	 * 4. 커맨드 객체 방식
	 * 해당 메소드의 매개변수로 요청시 전달 값을 담고자 하는 Vo클래스타입의 변수를 세팅하고, 요청시 전달 값의 name 속성값이 VO클래스의 
	 * 담고자하는 필드명과 일치시켜서 작성
	 * 
	 * 스프링 컨테이너에서 해당 객체를 "기본 생성자"로 호출해서 생성 후, 내부적으로 전달받은 key값에 해당하는 setter메서드를 찾아서
	 * 전달한 값을 필드에 담아준다. 따라서 반드시 name속성 값(키값)과 Vo객체의 필드명이 일치해야한다.
	 * */
//	@RequestMapping( value = "login.me", method = RequestMethod.POST) // RequestMapping이라는 어노테이션을 붙이면 HandlerMapping 곳에 등록이 된다.
//	public String loginMember(/* @ModelAttribute */ Member m) {
//		System.out.println("userId :"+m.getUserId());
//		System.out.println("userPwd :"+m.getUserPwd());
//		
//		return "main";
//	}
//	@RequestMapping( value = "login.me", method = RequestMethod.POST) // RequestMapping이라는 어노테이션을 붙이면 HandlerMapping 곳에 등록이 된다.
//	public ModelAndView loginMember(@ModelAttribute Member m, HttpSession session, Model model, ModelAndView mv) {
//		/*
//		 * 요청 처리 후 "응답 데이터를 담고" 응답페이지로 url 재요청 하는 방법.
//		 * 1. Model 객체 이용
//		 * 포워딩할 응답뷰로 전달하고자 하는 데이터를 맵 형식으로 담을 수 있는 객체 (Model객체는 RequestScope를 가지고 있음)
//		 * -> request, session을 대신하는 객체
//		 * 
//		 * - 기본 scope : request이고, Session scope로 변환하고 싶은 경우 클래스위dp @SessionAttribute를 작성하면 된다.
//		 * model안에 데이터를 추가하는 함수 : addAttribute()
//		 * 
//		 * 2. ModelAndView 객체 이용
//		 * ModelAndView에서 Model은 데이터를 담을 수 있는 Key-value 형태의 객체(위 Model과 동일)
//		 * View는 이동하고자 하는 페이지에 대한 정보를 담고 있는 객체 합쳐서 ModelAndView
//		 * mv에 model에 데이터를 추가하는 함수
//		 * mv.addObject(key,value)
//		 * mv에 view에 데이터를 추가하는 함수
//		 * mv.setViewName("이동할 페이지")
//		 * 
//		 * -> Model로 데이터를 전달하든, ModelAndView로 데이터를 전달하든 결국은 ModelAndView로 통합되서
//		 * Spring container에 의해 관리된다.
//		 * */ 
//		model.addAttribute("errorMsg", "오류발생"); // 보통은 모델을 사용한다 어쩌구저쩌구 
//		mv.addObject("errorMsg","modelAndView 테스트");
//		mv.setViewName("common/errorPage");
//		
//		System.out.println("userId :"+m.getUserId());
//		System.out.println("userPwd :"+m.getUserPwd());
//		
//		return mv;
//	}
	
	@PostMapping("/login.me")
	public String loginMember(
			@ModelAttribute Member m, 
			HttpSession session, 
			Model model
			) {
		// 암호화 전 로그인 요청 처리
		Member loginUser = mService.loginUser(m);
		String url = "";
		if(loginUser == null) {
			model.addAttribute("errorMsg", "오류발생");
			url = "common/errorPage";
		}else {
			session.setAttribute("loginUser", loginUser);
			url = "redirect:/";
		}
		
		System.out.println("userId :"+m.getUserId());
		System.out.println("userPwd :"+m.getUserPwd());
		
		return url;
	}
	
	@GetMapping("/logout.me")
	public String logoutMember(HttpSession session) {
		session.invalidate();
		return "redirect:/";
	}
	
	@GetMapping("/insert.me")
	public String enrollForm() {
		return "member/memberEnrollForm";
	}
	
	@PostMapping("/insert.me")
	public String insertMember(@Validated Member m, HttpSession session, Model model, BindingResult bindingResult) {
		// 404에러는 매개변수에 들어갈 값이 잘못된 파라미터가 들어가는 경우에 404에러가 뜬다.
		if(bindingResult.hasErrors()) {
			String errors = "";
			List<ObjectError>errorList = bindingResult.getAllErrors();
			for(ObjectError err : errorList) {
				errors += "{"+err.getCode()+":"+err.getDefaultMessage()+"} ";
				model.addAttribute("errorMsg",errors);
			}
			return "common/errorPage";
		}
		// 멤버 테이블에 회원가입등록 성공시 -> alertMsg 변수에 회원가입 성공 메세지 담아서 main페이지로 url재요청 보내기
		//					   실패시 -> errorMsg변수에 실패매세지 담아서, 에러페이지로 forwarding하기
		
		/*
		 * 비밀번호가 사용자가 입력한 그대로이기 때문에 보안에 문제가 있다.
		 * ->BCrypt방식의 암호화를 통해서 Pwd를 암호문으로 변경.
		 * 1. spring security 모듈에서 제공하는 라이브러리를 pom.xml 다운
		 * 2. BCryptPasswordEncoder 클래스를 xml파일에서 bean객체로 등록
		 * 3. web.xml에 2번에서 생성한 xml파일을 로딩할 수 있도록 param-value에 추가.
		*/
		
		System.out.println("암호화 전 비밀번호 :"+ m.getUserPwd());
		
		//암호화 작업
		String encPwd = bcryptPasswordEncoder.encode(m.getUserPwd());
		
		//암호화된 pwd를 Member m 에 담아주기
		m.setUserPwd(encPwd);
		
		System.out.println("암호화 후 비밀번호 : "+m.getUserPwd());
		
		// 1. memberservice호출해서 insertMember 실행(insert)
		int result = mService.insertMember(m);
		String url = "";
		
		if(result >  0) {
			session.setAttribute("alertMsg", "회원가입성공");
			url = "redirect:/";
		}else {
			model.addAttribute("errorMsg", "오류발생");
			url = "common/errorPage";
		}		
		
		return url;
	}
	

	
	@GetMapping("/myPage.me")
	public String myPage() {
		return "member/myPage";
	}
	
	@PostMapping("/update.me")
	public String updateMember(@Validated Member m, HttpSession session, Model model,RedirectAttributes ra) {
		// RedirectAttributes,  request scope 어쩌구 세션에 저장하지 않아도 사용할 수 있게 다시 공부하기
		
		int result = mService.updateMember(m);

		if(result > 0 ) {
			
			Member updateMember = mService.loginUser(m);
			session.setAttribute("loginUser", updateMember);
			ra.addFlashAttribute("alertMsg", "내정보수정 성공");
			// 1차적으로 alertMsg sessionScope로 이관
			// 리다이렉트 완료 후 sessionScope에 저장된 alertMsg를 requestScope로 다시 이관
			// 리소스가 많이 사용되기에 자주 쓰지는 말고 일회성으로 사용하길 권장 

//			return "member/myPage"; // forward -> 그 값을 그대로 유지한채로 해당 페이지 요청
			return "redirect:/mypage.me"; // redirect -> 새로고침을 실행 url요청
		}else {
			model.addAttribute("errorMsg", "회원정보수정실패");
			return "common/errorPage";
		}
		
	
	}
	
	// 내 정보 수정 성공시 -> myPage로 url 재요ㅓㅇ
	// 실패시 -> 에러페이지로
	
	
	
	
	/*
	 * 스프링 예외처리 방법 (3가지, 중복으로 사용 가능!)
	 * 1.메서드 별로 예외 처리(try-catch / throws) -> 1순위로 적용됨
	 * 
	 * 2.하나의 컨트롤러에서 발생하는 예외를 모아서 처리하는 방법 => @ExceptionHandler(메서드에 작성)->2순위
	 * 
	 * 3.전역에서 발생하는 예외를 모아서 처리하는 클래스 -> @ControllerAdvice(클래스에 작성)->3순위
	 * 
	*/
//	@ControllerAdvice
//	public class ExceptionController {
//		@ExceptionHandler(Exception.class)
//		public String exceprionHandler(Exception e, Model model) {
//			e.printStackTrace();
//			model.addAttribute("errorMsg","서비스 이용중 문제가 발생했습니다.");
//			return "common/";
//		}

	// 아이디 중복 검사 --> 비동기 요청
	@ResponseBody // 비동기 요청시 사용
	@GetMapping("/idCheck.me")
	public String idCheck(String userId) {
		int result = mService.idCheck(userId);
		/*
		 * 컨트롤러에서 반환되는 값은 forward 또는 redirect를 위한 경로인 경우가 일반적이다.
		 * 즉, 반환되는 값은 경로로서 인식한다.
		 * 이를 해결하기 위한 어노테이션이 @ResponseBody.
		 * -> 반환되는 값을 응답(response)의 몸통(body)에 추가하여 이전 요청 주소로 돌아감
		 * => 컨트롤러에서 반환되는 값이 경로가 아닌 "값 자체"로 인식된다.
		 * 
		*/
		return result+"";
	}
	/*
	 * Spring방식 ajax요청 처리 방법
	 * *jsonView 빈을 통해 데이터를 처리하기
	*/
	@PostMapping("/selectOne")
	public String selectOne1(String userId, Model model) {
		//1. 업무로직
		Member m = mService.selectOne(userId);
		model.addAttribute("userId",m.getUserId());
		model.addAttribute("userName",m.getUserName());
		
		// model객체 안에 담긴 데이터를 json으로 변환 후 응답처리 해줌.
		
		return "jsonView";

	}

	/*
	 * Spring방식 ajax요청 처리 방법
	 * *jsonView 빈을 통해 데이터를 처리하기
	*/
	@ResponseBody
	@PostMapping("/selectOne2")
	public Map<String, Object> selectOne2(String userId) {
		//1. 업무로직
		Member m = mService.selectOne(userId);
		Map<String, Object> map = new HashMap();
		
		if(m != null) {
			map.put("userId", m.getUserId());
			map.put("userName", m.getUserName());
		}
		return map;

	}
	
	@PostMapping("/selectOne3")
	public ResponseEntity<Map<String, Object>> selectOne3(String userId) {
		//1. 업무로직
		Member m = mService.selectOne(userId);
		Map<String, Object> map = new HashMap();
		
		ResponseEntity res = null;
		
		if(m != null) {
			map.put("userId", m.getUserId());
			map.put("userName", m.getUserName());
			
			res = ResponseEntity
					.ok()
					.header(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_UTF8_VALUE)
					.body(map);
			
		}else {
			res = ResponseEntity
				  .notFound()
				  .build();
		}
		
		return res;

	}
	
	
	
}
