{"ast":null,"code":"var _jsxFileName = \"C:\\\\react-workspace\\\\my-app\\\\src\\\\14_Callback.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\n/* \r\n  콜백함수 ?\r\n  자바스크립트의 함수중 비동기적으로 작동하는 코드는 실행된 작업이 끝나지 않았더라도\r\n  다음 작업이 시작될 수 있는데, 이때 특정 코드를 내가 원하는 시점에 실행될 수 있도록\r\n  컨트롤 해줘야할 때 콜백함수를 사용한다.\r\n\r\n  Promise\r\n  콜백함수와 마찬가지로 비동기적으로 동작하는 코드를 \"동기적으로\" 구현할 때 사용한다\r\n  콜백 함수와의 차이점은, 가독성이 높고, 예외처리가 가능하다\r\n*/\n\nimport { useEffect } from \"react\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction Callback() {\n  _s();\n  // 동기적으로 스크립트 파일을 불ㄹㅓ와야만 할때 간혹가다가 쓸일이 있다 (지현님 : 쓰기는 한다..)\n\n  useEffect(() => {\n    logPrint(1, function (return1) {\n      // 펑션안에 return1이 callback함수로 넘어가는 것\n      console.log(\"return1 : \" + return1);\n      logPrint(return1, return2 => {\n        console.log(\"return2 : \" + return2);\n      });\n    });\n    function logPrint(param, callback) {\n      console.log(\"logPrint param : \" + param);\n      param += param;\n      callback(param);\n    }\n  }, []);\n  return /*#__PURE__*/_jsxDEV(\"h1\", {\n    children: \"Callback Test\"\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 33,\n    columnNumber: 10\n  }, this);\n}\n_s(Callback, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n_c = Callback;\nfunction PromiseThen() {\n  _s2();\n  useEffect(() => {\n    /* \r\n      Promise 내부에는 대기, 이행, 거부의 개념이 있다\r\n      대기상태에서 이행 상태로 변할 때 then()내부에 있는 함수가 실행된다.\r\n        reject? 대기, 이행, 거부중 거부 상태가 됐을 때 ㅊㅁ\r\n      */\n    new Promise(resolve => {\n      setTimeout(() => {\n        resolve('promise');\n      }, 1500); // 1.5초 후에 setTimeout 함수의 첫번째 매개변수로 전달 받은 콜백 함수가 실행된다.\n    }).then(result => {\n      console.log(result); // 'promise'\n      return result + 'then'; // then 함수 내부에서 값이 반환되는 순간 다음 then실행된다.\n    }).then(result => {\n      console.log(result);\n    });\n  }, []);\n  return /*#__PURE__*/_jsxDEV(\"h1\", {\n    children: \"Promise Then\"\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 63,\n    columnNumber: 10\n  }, this);\n}\n_s2(PromiseThen, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n_c2 = PromiseThen;\nexport { Callback, PromiseThen };\nvar _c, _c2;\n$RefreshReg$(_c, \"Callback\");\n$RefreshReg$(_c2, \"PromiseThen\");","map":{"version":3,"names":["useEffect","jsxDEV","_jsxDEV","Callback","_s","logPrint","return1","console","log","return2","param","callback","children","fileName","_jsxFileName","lineNumber","columnNumber","_c","PromiseThen","_s2","Promise","resolve","setTimeout","then","result","_c2","$RefreshReg$"],"sources":["C:/react-workspace/my-app/src/14_Callback.js"],"sourcesContent":["/* \r\n  콜백함수 ?\r\n  자바스크립트의 함수중 비동기적으로 작동하는 코드는 실행된 작업이 끝나지 않았더라도\r\n  다음 작업이 시작될 수 있는데, 이때 특정 코드를 내가 원하는 시점에 실행될 수 있도록\r\n  컨트롤 해줘야할 때 콜백함수를 사용한다.\r\n\r\n  Promise\r\n  콜백함수와 마찬가지로 비동기적으로 동작하는 코드를 \"동기적으로\" 구현할 때 사용한다\r\n  콜백 함수와의 차이점은, 가독성이 높고, 예외처리가 가능하다\r\n*/\r\n\r\nimport { useEffect } from \"react\";\r\n\r\nfunction Callback(){    // 동기적으로 스크립트 파일을 불ㄹㅓ와야만 할때 간혹가다가 쓸일이 있다 (지현님 : 쓰기는 한다..)\r\n\r\n\r\n  useEffect( () => {\r\n    logPrint(1, function(return1){ // 펑션안에 return1이 callback함수로 넘어가는 것\r\n      console.log(\"return1 : \"+ return1);\r\n      logPrint(return1, (return2)=> {\r\n        console.log(\"return2 : \"+return2);\r\n      })\r\n\r\n    })\r\n\r\n    function logPrint(param, callback){\r\n      console.log(\"logPrint param : \" + param);\r\n      param += param;\r\n      callback(param);\r\n    }\r\n  },[])\r\n\r\n  return <h1>Callback Test</h1>\r\n}\r\n\r\nfunction PromiseThen(){\r\n  useEffect( () => {\r\n    /* \r\n      Promise 내부에는 대기, 이행, 거부의 개념이 있다\r\n      대기상태에서 이행 상태로 변할 때 then()내부에 있는 함수가 실행된다.\r\n\r\n      reject? 대기, 이행, 거부중 거부 상태가 됐을 때 ㅊㅁ\r\n\r\n    */\r\n   new Promise(\r\n    (resolve) => {\r\n      setTimeout( () => {\r\n        resolve('promise');\r\n      }, 1500); // 1.5초 후에 setTimeout 함수의 첫번째 매개변수로 전달 받은 콜백 함수가 실행된다.\r\n    }\r\n   ). then(\r\n    (result) =>{\r\n      console.log(result); // 'promise'\r\n      return result + 'then'; // then 함수 내부에서 값이 반환되는 순간 다음 then실행된다.\r\n    }\r\n   ).then(\r\n    result => {\r\n      console.log(result);\r\n    }\r\n   );\r\n\r\n  },[])\r\n  return <h1>Promise Then</h1>\r\n}\r\nexport {Callback, PromiseThen};"],"mappings":";;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASA,SAAS,QAAQ,OAAO;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAElC,SAASC,QAAQA,CAAA,EAAE;EAAAC,EAAA;EAAK;;EAGtBJ,SAAS,CAAE,MAAM;IACfK,QAAQ,CAAC,CAAC,EAAE,UAASC,OAAO,EAAC;MAAE;MAC7BC,OAAO,CAACC,GAAG,CAAC,YAAY,GAAEF,OAAO,CAAC;MAClCD,QAAQ,CAACC,OAAO,EAAGG,OAAO,IAAI;QAC5BF,OAAO,CAACC,GAAG,CAAC,YAAY,GAACC,OAAO,CAAC;MACnC,CAAC,CAAC;IAEJ,CAAC,CAAC;IAEF,SAASJ,QAAQA,CAACK,KAAK,EAAEC,QAAQ,EAAC;MAChCJ,OAAO,CAACC,GAAG,CAAC,mBAAmB,GAAGE,KAAK,CAAC;MACxCA,KAAK,IAAIA,KAAK;MACdC,QAAQ,CAACD,KAAK,CAAC;IACjB;EACF,CAAC,EAAC,EAAE,CAAC;EAEL,oBAAOR,OAAA;IAAAU,QAAA,EAAI;EAAa;IAAAC,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OAAI,CAAC;AAC/B;AAACZ,EAAA,CApBQD,QAAQ;AAAAc,EAAA,GAARd,QAAQ;AAsBjB,SAASe,WAAWA,CAAA,EAAE;EAAAC,GAAA;EACpBnB,SAAS,CAAE,MAAM;IACf;AACJ;AACA;AACA;AACA;IAGG,IAAIoB,OAAO,CACTC,OAAO,IAAK;MACXC,UAAU,CAAE,MAAM;QAChBD,OAAO,CAAC,SAAS,CAAC;MACpB,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC;IACZ,CACD,CAAC,CAAEE,IAAI,CACLC,MAAM,IAAI;MACTjB,OAAO,CAACC,GAAG,CAACgB,MAAM,CAAC,CAAC,CAAC;MACrB,OAAOA,MAAM,GAAG,MAAM,CAAC,CAAC;IAC1B,CACD,CAAC,CAACD,IAAI,CACLC,MAAM,IAAI;MACRjB,OAAO,CAACC,GAAG,CAACgB,MAAM,CAAC;IACrB,CACD,CAAC;EAEF,CAAC,EAAC,EAAE,CAAC;EACL,oBAAOtB,OAAA;IAAAU,QAAA,EAAI;EAAY;IAAAC,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OAAI,CAAC;AAC9B;AAACG,GAAA,CA5BQD,WAAW;AAAAO,GAAA,GAAXP,WAAW;AA6BpB,SAAQf,QAAQ,EAAEe,WAAW;AAAE,IAAAD,EAAA,EAAAQ,GAAA;AAAAC,YAAA,CAAAT,EAAA;AAAAS,YAAA,CAAAD,GAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}