{"ast":null,"code":"var _jsxFileName = \"C:\\\\react-workspace\\\\my-app\\\\src\\\\12_Fetch.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport { useEffect } from 'react';\n/* \r\n  Fetch?\r\n  자바스크립트 내장 함수로, 비동기 통신을 구현할 때 사용 (ajax로 사용할 수 있지만 그러려면 뭐를 다 불러와야해서 번거롭다)\r\n  * 비동기 통신 -> 먼저 시작한 작업의 완료 여부와 상관없이 다음 작업을 실행하는 것.\r\n\r\n  fetch함수를 이용하여 get/post 방식으로 url호출하여 데이터를 가져온다.\r\n\r\n */\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction FetchGet() {\n  _s();\n  useEffect(() => {\n    const fetchData = async () => {\n      /* \r\n        Get방식 요청시 별도의 추가메소드는 사용하지 않고\r\n        url뒤에 내가 전달하고자하는 값을 붙여서 전송한다.\r\n      */\n      const response = await fetch(\"http://date.jsontest.com?a=1\");\n      // console.log(response.json()); \n      // json? response중 body에 있는 부분을 JSON형식으로 디코딩한다. => Javascript 객체로 변환.  JSON 형태의 문자열 데이터가 자바스크립트의 데이터가 되는 것\n      /*\r\n        async ~ await 을 붙인 이유?\r\n        fetch함수, json함수 같은 경우 비동기적으로 작동하기 때문에 url을 호출하고\r\n        데이터를 가져오기 전에 response.json()메서드가 실행되면 에러가 발생할 수 있다.\r\n        (json 합수는 JSON형태의 문자열 객체에서만 사용이 가능하다.)\r\n          따라서 데이터를 전부 다 가져온 후에 아래 json함수가 호출되도록 흐름을 동기적으로 변환시켰다.\r\n      */\n\n      const body = await response.json(); // 디코딩된 자바스크립트 파일이 담긴게 아니기 때문에 언디파인드가 되는 것 await로 동기전 변환을 해줘야 해결 할 수 있다.\n      alert(body.date);\n    };\n    fetchData();\n  });\n  return /*#__PURE__*/_jsxDEV(\"h1\", {\n    children: \"fetch get test\"\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 37,\n    columnNumber: 12\n  }, this);\n}\n_s(FetchGet, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n_c = FetchGet;\nfunction FetchPost() {\n  _s2();\n  useEffect(() => {\n    const fetchData = async () => {\n      const response = await fetch(\"hppt://date.jsontest.com\", {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n          // json형태의 데이터를 사용하기 위한 설정.\n        },\n\n        body: JSON.stringify({\n          a: \"test1\",\n          b: \"test2\"\n        })\n      });\n      const body = await response.json();\n    };\n    fetchData();\n  }, []);\n  return /*#__PURE__*/_jsxDEV(\"h1\", {\n    children: \"Fetch Post Text\"\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 61,\n    columnNumber: 7\n  }, this);\n}\n_s2(FetchPost, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n_c2 = FetchPost;\nexport { FetchGet, FetchPost };\nvar _c, _c2;\n$RefreshReg$(_c, \"FetchGet\");\n$RefreshReg$(_c2, \"FetchPost\");","map":{"version":3,"names":["useEffect","jsxDEV","_jsxDEV","FetchGet","_s","fetchData","response","fetch","body","json","alert","date","children","fileName","_jsxFileName","lineNumber","columnNumber","_c","FetchPost","_s2","method","headers","JSON","stringify","a","b","_c2","$RefreshReg$"],"sources":["C:/react-workspace/my-app/src/12_Fetch.js"],"sourcesContent":["import {useEffect} from 'react';\r\n/* \r\n  Fetch?\r\n  자바스크립트 내장 함수로, 비동기 통신을 구현할 때 사용 (ajax로 사용할 수 있지만 그러려면 뭐를 다 불러와야해서 번거롭다)\r\n  * 비동기 통신 -> 먼저 시작한 작업의 완료 여부와 상관없이 다음 작업을 실행하는 것.\r\n\r\n  fetch함수를 이용하여 get/post 방식으로 url호출하여 데이터를 가져온다.\r\n\r\n */\r\n\r\n  function FetchGet(){\r\n    useEffect(() => {\r\n      const fetchData = async () =>{\r\n        /* \r\n          Get방식 요청시 별도의 추가메소드는 사용하지 않고\r\n          url뒤에 내가 전달하고자하는 값을 붙여서 전송한다.\r\n        */\r\n        const response = await fetch(\"http://date.jsontest.com?a=1\");\r\n        // console.log(response.json()); \r\n        // json? response중 body에 있는 부분을 JSON형식으로 디코딩한다. => Javascript 객체로 변환.  JSON 형태의 문자열 데이터가 자바스크립트의 데이터가 되는 것\r\n        /*\r\n          async ~ await 을 붙인 이유?\r\n          fetch함수, json함수 같은 경우 비동기적으로 작동하기 때문에 url을 호출하고\r\n          데이터를 가져오기 전에 response.json()메서드가 실행되면 에러가 발생할 수 있다.\r\n          (json 합수는 JSON형태의 문자열 객체에서만 사용이 가능하다.)\r\n\r\n          따라서 데이터를 전부 다 가져온 후에 아래 json함수가 호출되도록 흐름을 동기적으로 변환시켰다.\r\n        */\r\n\r\n        const body = await response.json(); // 디코딩된 자바스크립트 파일이 담긴게 아니기 때문에 언디파인드가 되는 것 await로 동기전 변환을 해줘야 해결 할 수 있다.\r\n        alert(body.date);\r\n\r\n      };\r\n      fetchData();\r\n    });\r\n\r\n    return <h1>fetch get test</h1>\r\n\r\n  }\r\n  function FetchPost(){\r\n    useEffect( () => {\r\n      const fetchData = async () => {\r\n        const response = await fetch(\"hppt://date.jsontest.com\",\r\n        {\r\n          method : 'POST',\r\n          headers : {\r\n            'Content-Type' : 'application/json'\r\n            // json형태의 데이터를 사용하기 위한 설정.\r\n          },\r\n          body : JSON.stringify ({\r\n            a : \"test1\",\r\n            b : \"test2\"\r\n          })\r\n        });\r\n        const body = await response.json();\r\n      }\r\n      fetchData();\r\n    },[])\r\n\r\n    return(\r\n      <h1>Fetch Post Text</h1>\r\n    )\r\n  }\r\n  export {FetchGet, FetchPost};"],"mappings":";;;AAAA,SAAQA,SAAS,QAAO,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA,SAAAC,MAAA,IAAAC,OAAA;AASE,SAASC,QAAQA,CAAA,EAAE;EAAAC,EAAA;EACjBJ,SAAS,CAAC,MAAM;IACd,MAAMK,SAAS,GAAG,MAAAA,CAAA,KAAW;MAC3B;AACR;AACA;AACA;MACQ,MAAMC,QAAQ,GAAG,MAAMC,KAAK,CAAC,8BAA8B,CAAC;MAC5D;MACA;MACA;AACR;AACA;AACA;AACA;AACA;AACA;;MAGQ,MAAMC,IAAI,GAAG,MAAMF,QAAQ,CAACG,IAAI,CAAC,CAAC,CAAC,CAAC;MACpCC,KAAK,CAACF,IAAI,CAACG,IAAI,CAAC;IAElB,CAAC;IACDN,SAAS,CAAC,CAAC;EACb,CAAC,CAAC;EAEF,oBAAOH,OAAA;IAAAU,QAAA,EAAI;EAAc;IAAAC,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OAAI,CAAC;AAEhC;AAACZ,EAAA,CA5BQD,QAAQ;AAAAc,EAAA,GAARd,QAAQ;AA6BjB,SAASe,SAASA,CAAA,EAAE;EAAAC,GAAA;EAClBnB,SAAS,CAAE,MAAM;IACf,MAAMK,SAAS,GAAG,MAAAA,CAAA,KAAY;MAC5B,MAAMC,QAAQ,GAAG,MAAMC,KAAK,CAAC,0BAA0B,EACvD;QACEa,MAAM,EAAG,MAAM;QACfC,OAAO,EAAG;UACR,cAAc,EAAG;UACjB;QACF,CAAC;;QACDb,IAAI,EAAGc,IAAI,CAACC,SAAS,CAAE;UACrBC,CAAC,EAAG,OAAO;UACXC,CAAC,EAAG;QACN,CAAC;MACH,CAAC,CAAC;MACF,MAAMjB,IAAI,GAAG,MAAMF,QAAQ,CAACG,IAAI,CAAC,CAAC;IACpC,CAAC;IACDJ,SAAS,CAAC,CAAC;EACb,CAAC,EAAC,EAAE,CAAC;EAEL,oBACEH,OAAA;IAAAU,QAAA,EAAI;EAAe;IAAAC,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OAAI,CAAC;AAE5B;AAACG,GAAA,CAvBQD,SAAS;AAAAQ,GAAA,GAATR,SAAS;AAwBlB,SAAQf,QAAQ,EAAEe,SAAS;AAAE,IAAAD,EAAA,EAAAS,GAAA;AAAAC,YAAA,CAAAV,EAAA;AAAAU,YAAA,CAAAD,GAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}